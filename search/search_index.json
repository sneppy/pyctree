{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyCTree PyCTree is a collection of tree-based containers for Python, written in C. Installation You can download and install the latest version from TestPyPI: $ pip install --index-url https://test.pypi.org/simple/ pyctree Building from source Alternatively, you can clone this repository and manually build the module: $ git clone https://github.com/sneppy/pyctree.git $ cd pyctree $ python setup.py install Note that you need to install the python3.x-dev package, e.g.: $ sudo apt-get install python3.6-dev","title":"Welcome page"},{"location":"#pyctree","text":"PyCTree is a collection of tree-based containers for Python, written in C.","title":"PyCTree"},{"location":"#installation","text":"You can download and install the latest version from TestPyPI: $ pip install --index-url https://test.pypi.org/simple/ pyctree","title":"Installation"},{"location":"#building-from-source","text":"Alternatively, you can clone this repository and manually build the module: $ git clone https://github.com/sneppy/pyctree.git $ cd pyctree $ python setup.py install Note that you need to install the python3.x-dev package, e.g.: $ sudo apt-get install python3.6-dev","title":"Building from source"},{"location":"api/","text":"API reference API reference Tree class Tree([iterable]) len(t) x in t add(item) update(*iterables) remove(key) discard(key) clear() copy() left_bound(key) right_bound(key) SortedSet SortedDict Tree The Tree type implements a binary tree with auto-balancing logic (red-black tree algorithm). All methods of Tree , unless stated otherwise, use __lt__ and __gt__ operators to determine the position of a value in the tree: if lhs < rhs : # go left elif lhs > rhs : # go right else : # value found The term key is broadly used to refer to the property(s) of the item that determines its position in the tree. class Tree ([ iterable ]) Returns a new tree instance. The items of the tree are taken from the iterable object, if given. len ( t ) Returns the number of items in the tree. x in t Returns True if the tree contains one or more items matching the given key, False otherwise. add ( item ) Add item to the tree. update ( * iterables ) Insert items in the tree taken from zero or more iterables . remove ( key ) Remove the first item that matches the given key from the tree. If no item matches the key, raises a KeyError . discard ( key ) Like remove() , but does not raise a KeyError if no item matches the key. clear () Removes all items from the tree. copy () Creates a shallow copy of the tree. left_bound ( key ) Returns the item that partitions the tree in such a way that all previous items are smaller and all next items are larger or equal. The item, if it exists, is unique (though it may depend on the order in which the items were inserted in the tree, if there are multiple items with the same key). right_bound ( key ) Returns the item that partitions the tree in such a way that all previous items are smaller or equal and all next items are larger. See left_bound ( key ) for additional info. SortedSet WIP SortedDict TODO","title":"API reference"},{"location":"api/#api-reference","text":"API reference Tree class Tree([iterable]) len(t) x in t add(item) update(*iterables) remove(key) discard(key) clear() copy() left_bound(key) right_bound(key) SortedSet SortedDict","title":"API reference"},{"location":"api/#tree","text":"The Tree type implements a binary tree with auto-balancing logic (red-black tree algorithm). All methods of Tree , unless stated otherwise, use __lt__ and __gt__ operators to determine the position of a value in the tree: if lhs < rhs : # go left elif lhs > rhs : # go right else : # value found The term key is broadly used to refer to the property(s) of the item that determines its position in the tree.","title":"Tree"},{"location":"api/#class-treeiterable","text":"Returns a new tree instance. The items of the tree are taken from the iterable object, if given.","title":"class Tree([iterable])"},{"location":"api/#lent","text":"Returns the number of items in the tree.","title":"len(t)"},{"location":"api/#x-in-t","text":"Returns True if the tree contains one or more items matching the given key, False otherwise.","title":"x in t"},{"location":"api/#additem","text":"Add item to the tree.","title":"add(item)"},{"location":"api/#updateiterables","text":"Insert items in the tree taken from zero or more iterables .","title":"update(*iterables)"},{"location":"api/#removekey","text":"Remove the first item that matches the given key from the tree. If no item matches the key, raises a KeyError .","title":"remove(key)"},{"location":"api/#discardkey","text":"Like remove() , but does not raise a KeyError if no item matches the key.","title":"discard(key)"},{"location":"api/#clear","text":"Removes all items from the tree.","title":"clear()"},{"location":"api/#copy","text":"Creates a shallow copy of the tree.","title":"copy()"},{"location":"api/#left_boundkey","text":"Returns the item that partitions the tree in such a way that all previous items are smaller and all next items are larger or equal. The item, if it exists, is unique (though it may depend on the order in which the items were inserted in the tree, if there are multiple items with the same key).","title":"left_bound(key)"},{"location":"api/#right_boundkey","text":"Returns the item that partitions the tree in such a way that all previous items are smaller or equal and all next items are larger. See left_bound ( key ) for additional info.","title":"right_bound(key)"},{"location":"api/#sortedset","text":"WIP","title":"SortedSet"},{"location":"api/#sorteddict","text":"TODO","title":"SortedDict"}]}